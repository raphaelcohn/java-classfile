// The MIT License (MIT)
//
// Copyright © 2016, Raphael Cohn <raphael.cohn@stormmq.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package com.stormmq.java.classfile.parser.javaClassFileParsers.accessFlags;

import com.stormmq.java.classfile.domain.JavaClassFileVersion;
import com.stormmq.java.classfile.domain.names.MethodName;
import com.stormmq.java.classfile.parser.javaClassFileParsers.exceptions.InvalidJavaClassFileException;
import com.stormmq.java.parsing.utilities.Completeness;
import com.stormmq.java.parsing.utilities.Visibility;
import org.jetbrains.annotations.NotNull;

import static com.stormmq.java.classfile.domain.names.MethodName.StaticInstanceInitializer;
import static com.stormmq.java.classfile.parser.javaClassFileParsers.accessFlags.AccessFlags.hasFlagSet;
import static com.stormmq.java.parsing.utilities.Completeness.*;
import static com.stormmq.java.parsing.utilities.Visibility.*;

public final class MethodAccessFlags
{
	private static final char ACC_PUBLIC = 0x0001; // Declared public; may be accessed from outside its package.
	private static final char ACC_PRIVATE = 0x0002; // 	Declared private; usable only within the defining class.
	private static final char ACC_PROTECTED = 0x0004; // Declared protected; may be accessed within subclasses.
	private static final char ACC_STATIC = 0x0008; // Declared static.
	private static final char ACC_FINAL = 0x0010; // Declared final; no subclasses allowed.
	private static final char ACC_SYNCHRONIZED = 0x0020; // Declared synchronized; invocation is wrapped by a monitor use.
	private static final char ACC_BRIDGE = 0x0040; // A bridge method, generated by the compiler.
	private static final char ACC_VARARGS = 0x0080; // Declared with variable number of arguments.
	private static final char ACC_NATIVE = 0x0100; // Declared native; implemented in a language other than Java.
	private static final char ACC_ABSTRACT = 0x0400; // Declared abstract; no implementation is provided.
	private static final char ACC_STRICT = 0x0800; // Declared strictfp; floating-point mode is FP-strict.
	private static final char ACC_SYNTHETIC = 0x1000; // Declared synthetic; not present in the source code.

	public static final int MethodAccessFlagsValidityMask = ~(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED | ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC);

	@NotNull
	public static Visibility validateAccessFlags(final char accessFlags, final boolean isInterfaceOrAnnotation, @NotNull final JavaClassFileVersion javaClassFileVersion, @NotNull final MethodName methodName) throws InvalidJavaClassFileException
	{
		// Class and interface initialization methods are called implicitly by the Java Virtual Machine. The value of their access_flags item is ignored except for the setting of the ACC_STRICT flag.
		if (methodName.equals(StaticInstanceInitializer))
		{
			return Private;
		}

		final boolean isPublic = hasFlagSet(accessFlags, ACC_PUBLIC);
		final boolean isProtected = hasFlagSet(accessFlags, ACC_PROTECTED);
		final boolean isPrivate = hasFlagSet(accessFlags, ACC_PRIVATE);

		final Visibility visibility;

		// Methods of interfaces may have any of the flags in Table 4.6-A set except ACC_PROTECTED, ACC_FINAL, ACC_SYNCHRONIZED, and ACC_NATIVE (JLS §9.4).
		if (isInterfaceOrAnnotation)
		{
			if (isProtected)
			{
				throw new InvalidJavaClassFileException("An interface or annotation method can be protected");
			}

			if (hasFlagSet(accessFlags, ACC_FINAL))
			{
				throw new InvalidJavaClassFileException("An interface or annotation method can be final");
			}

			if (hasFlagSet(accessFlags, ACC_SYNCHRONIZED))
			{
				throw new InvalidJavaClassFileException("An interface or annotation method can be synchronized");
			}

			if (hasFlagSet(accessFlags, ACC_NATIVE))
			{
				throw new InvalidJavaClassFileException("An interface or annotation method can be native");
			}

			// In a class file whose version number is less than 52.0, each method of an interface must have its ACC_PUBLIC and ACC_ABSTRACT flags set
			if (javaClassFileVersion.isLessThanJava8())
			{
				if (!(isPublic && hasFlagSet(accessFlags, ACC_ABSTRACT)))
				{
					throw new InvalidJavaClassFileException("In a class file before Java 8, each method of an interface (or annotation) must be public and abstract");
				}
				visibility = Public;
			}
			// In a class file whose version number is 52.0 or above, each method of an interface must have exactly one of its ACC_PUBLIC and ACC_PRIVATE flags set.
			else
			{
				//noinspection StatementWithEmptyBody
				if (isPublic || isPrivate)
				{
					// Left as an empty branch because this logic is much easier to read
				}
				else
				{
					throw new InvalidJavaClassFileException("In a class file in Java 8 and later, each method of an interface (or annotation) must be either public or private");
				}
				visibility = isPublic ? Public : Private;
			}
		}
		else
		{
			// Methods of classes may have any of the flags in Table 4.6-A set. However, each method of a class may have at most one of its ACC_PUBLIC, ACC_PRIVATE, and ACC_PROTECTED flags set (JLS §8.4.3).
			visibility = methodVisibility(isPublic, isProtected, isPrivate);
		}

		// If a method of a class or interface has its ACC_ABSTRACT flag set, it must not have any of its ACC_PRIVATE, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, ACC_NATIVE, or ACC_STRICT flags set.
		if (hasFlagSet(accessFlags, ACC_ABSTRACT))
		{
			if (isPrivate)
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and private");
			}

			if (hasFlagSet(accessFlags, ACC_STATIC))
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and static");
			}

			if (hasFlagSet(accessFlags, ACC_FINAL))
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and final");
			}

			if (hasFlagSet(accessFlags, ACC_SYNCHRONIZED))
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and synchronized");
			}

			if (hasFlagSet(accessFlags, ACC_NATIVE))
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and native");
			}

			if (hasFlagSet(accessFlags, ACC_STRICT))
			{
				throw new InvalidJavaClassFileException("A method can not be abstract and strictfp");
			}
		}

		// Each instance initialization method (§2.9) may have at most one of its ACC_PUBLIC, ACC_PRIVATE, and ACC_PROTECTED flags set, and may also have its ACC_VARARGS, ACC_STRICT, and ACC_SYNTHETIC flags set, but must not have any of the other flags in Table 4.6-A set.
		if (methodName.equals(MethodName.InstanceInitializer))
		{
			if (isPublic && isPrivate)
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be public and private");
			}

			// To match JLS language
			//noinspection StatementWithEmptyBody
			if (hasFlagSet(accessFlags, ACC_VARARGS) || hasFlagSet(accessFlags, ACC_STRICT) || hasFlagSet(accessFlags, ACC_SYNTHETIC))
			{
			}

			if (hasFlagSet(accessFlags, ACC_STATIC))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be static");
			}

			if (hasFlagSet(accessFlags, ACC_FINAL))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be final");
			}

			if (hasFlagSet(accessFlags, ACC_SYNCHRONIZED))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be synchronized");
			}

			if (hasFlagSet(accessFlags, ACC_BRIDGE))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be bridge");
			}

			if (hasFlagSet(accessFlags, ACC_NATIVE))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be native");
			}

			if (hasFlagSet(accessFlags, ACC_ABSTRACT))
			{
				throw new InvalidJavaClassFileException("Instance initializers can not be abstract");
			}
		}

		return visibility;
	}

	public static boolean isMethodSynthetic(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_SYNTHETIC);
	}

	public static boolean isMethodBridge(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_BRIDGE);
	}

	public static boolean isMethodVarArgs(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_VARARGS);
	}

	public static boolean isMethodStatic(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_STATIC);
	}

	public static boolean isMethodNative(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_NATIVE);
	}

	public static boolean isMethodSynchronized(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_SYNCHRONIZED);
	}

	public static boolean isMethodStrictFloatingPoint(final char accessFlags)
	{
		return hasFlagSet(accessFlags, ACC_STRICT);
	}

	@NotNull
	public static Completeness methodCompleteness(final char accessFlags) throws InvalidJavaClassFileException
	{
		final boolean isAbstract = hasFlagSet(accessFlags, ACC_ABSTRACT);
		final boolean isFinal = hasFlagSet(accessFlags, ACC_FINAL);
		if (isAbstract && isFinal)
		{
			throw new InvalidJavaClassFileException("Method access flags can not be both abstract and final");
		}
		if (isAbstract)
		{
			return Abstract;
		}
		if (isFinal)
		{
			return Final;
		}
		return Normal;
	}

	@NotNull
	private static Visibility methodVisibility(final boolean isPublic, final boolean isProtected, final boolean isPrivate) throws InvalidJavaClassFileException
	{
		if (isPublic)
		{
			if (isProtected)
			{
				throw new InvalidJavaClassFileException("A method can not be public and protected");
			}

			if (isPrivate)
			{
				throw new InvalidJavaClassFileException("A method can not be public and private");
			}

			return Public;
		}

		if (isProtected)
		{
			if (isPrivate)
			{
				throw new InvalidJavaClassFileException("A method can not be protected and private");
			}

			return Protected;
		}

		if (isPrivate)
		{
			return Private;
		}

		return PackageLocal;
	}

	private MethodAccessFlags()
	{
	}
}
